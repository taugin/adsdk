import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import java.security.MessageDigest


def toUpperCaseFirstOne(String s) {
    if (Character.isUpperCase(s.charAt(0))) {
        return s;
    }
    return (new StringBuilder()).append(Character.toUpperCase(s.charAt(0))).append(s.substring(1)).toString();
}

project.afterEvaluate {
    if (project.android.productFlavors.size() > 0) {
        project.android.productFlavors.each { flavor ->
            def productFlavor = toUpperCaseFirstOne(flavor.name)
            String taskName = String.format("transformResourcesWithMergeJavaResFor%sRelease", productFlavor)
            def rTask = project.tasks.getByName(taskName)
            if (rTask != null) {
                String encryptTaskName = String.format("encrypt%sRelease", productFlavor)
                project.tasks.create(encryptTaskName, {
                    doLast {
                        encryptAssetsFiles(flavor.name)
                    }
                })
                rTask.dependsOn encryptTaskName
            }
        }
    } else {
        def rTask = project.tasks.getByName("transformResourcesWithMergeJavaResForRelease")
        if (rTask != null) {
            String encryptRelease = "encryptRelease"
            project.tasks.create(encryptRelease, {
                doLast {
                    encryptAssetsFiles(null)
                }
            })
            rTask.dependsOn encryptRelease
        }
    }
}

/**
 * 获取applicationId
 * @param flaver
 * @return
 */
def getApplicationId(flaver) {
    if (flaver == null || flaver.trim().length() == 0) {
        return project.android.defaultConfig.applicationId
    }
    def productFlavor = project.android.productFlavors[flaver]
    if (productFlavor.applicationId == null) {
        return project.android.defaultConfig.applicationId
    }
    return productFlavor.applicationId
}

/**
 * 获取assets输出目录
 * @param flaver
 * @return
 */
def getAssetsOutDir(flaver) {
    def outAssetsDir = String.format("intermediates/assets/%srelease", flaver == null ? "" : flaver + "/")
    def mergeAssetsDir = String.format("intermediates/merged_assets/%srelease/mergeReleaseAssets/out", flaver == null ? "" : flaver + "/")
    outAssetsDir = new File(project.getBuildDir(), outAssetsDir)
    mergeAssetsDir = new File(project.getBuildDir(), mergeAssetsDir)
    if (outAssetsDir.exists()) {
        return outAssetsDir;
    }
    if (mergeAssetsDir.exists()) {
        return mergeAssetsDir;
    }
    return null
}

/**
 * 获取广告配置文件名称
 * @param assetsDir
 * @param appId
 * @return
 */
def getAdConfigFile(assetsDir, appId) {
    def pkgnameMd5 = Aes.string2MD5(appId)
    def adConfigName = "cfg" + pkgnameMd5.substring(0, 8) + ".dat"
    def adConfigFile = new File(assetsDir, adConfigName)
    def adDefaultFile = new File(assetsDir, "data_config.dat")
    if (adConfigFile.exists()) {
        return adConfigFile.getAbsolutePath()
    }
    if (adDefaultFile.exists()) {
        return adDefaultFile.getAbsolutePath()
    }
    return null
}

def getEncryptFileTree(assetDir) {
    def output = ext != null && ext.has("encryptFiles") ? ext.encryptFiles : null
    if (output != null) {
        FileTree mainTree = fileTree(dir: assetDir)
        output.each {
            out ->
                mainTree.include out
        }
        return mainTree
    }
    return null
}

/**
 * 加密asset文件
 * @param flaver
 * @return
 */
def encryptAssetsFiles(flaver) {
    def secret = ext != null && ext.has("secret") ? ext["secret"] : "123456789"
    def appId = getApplicationId(flaver)
    def assetDir = getAssetsOutDir(flaver)
    if (assetDir == null) {
        System.err.println("[ERROR] Can not find the output Asset Dir");
    }
    def adFile = getAdConfigFile(assetDir, appId);
    def mainTree = getEncryptFileTree(assetDir)
    // println "flaver     : " + flaver
    // println "appId      : " + appId
    // println "secret     : " + secret
    // println "assetDir   : " + assetDir
    println "encrypt file : " + adFile
    Aes.encryptFile(adFile, secret)
    if (mainTree != null) {
        mainTree.each { File file ->
            println "encrypt file : " + file
            try {
                Aes.encryptFile(file.getAbsolutePath(), secret)
            } catch (Exception e) {
                e.printStackTrace()
            }
        }
    }
}

public class Aes {
    private static void appendHex(StringBuffer paramStringBuffer, byte paramByte) {
        paramStringBuffer.append(
                "0123456789ABCDEF".charAt(0xF & paramByte >> 4)).append(
                "0123456789ABCDEF".charAt(paramByte & 0xF));
    }

    public static String decrypt(String key, String content) {
        try {
            String str = new String(decrypt(getRawKey(key.getBytes()),
                    toByte(content)));
            return str;
        } catch (Exception localException) {
            System.out.println("decrypt error: " + localException);
        }
        return null;
    }

    public static byte[] decrypt(byte[] key,
                                 byte[] content) throws Exception {
        SecretKeySpec localSecretKeySpec = new SecretKeySpec(key,
                "AES");
        Cipher localCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        localCipher.init(2, localSecretKeySpec, new IvParameterSpec(
                new byte[localCipher.getBlockSize()]));
        return localCipher.doFinal(content);
    }

    public static String decryptRaw(String seed, byte[] content) {
        try {
            String str = new String(
                    decrypt(getRawKey(seed.getBytes()), content));
            return str;
        } catch (Exception localException) {
            System.out.println("decrypt raw error: " + localException);
        }
        return null;
    }

    public static String encryptPublic(String key, String content) {
        try {
            byte[] result = encrypt(getRawKey(key.getBytes()),
                    content.getBytes());
            return toHex(result);
        } catch (Exception localException) {
        }
        return null;
    }

    private static byte[] encrypt(byte[] key,
                                  byte[] content) throws Exception {
        SecretKeySpec localSecretKeySpec = new SecretKeySpec(key,
                "AES");
        Cipher localCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        localCipher.init(1, localSecretKeySpec, new IvParameterSpec(
                new byte[localCipher.getBlockSize()]));
        return localCipher.doFinal(content);
    }

    public static byte[] encryptRaw(String key, String content) {
        try {
            byte[] arrayOfByte = encrypt(getRawKey(key.getBytes()),
                    content.getBytes());
            return arrayOfByte;
        } catch (Exception localException) {
            System.out.println("encrypt raw error: " + localException);
        }
        return null;
    }

    public static String fromHex(String content) {
        return new String(toByte(content));
    }

    private static byte[] getRawKey(byte[] key) throws Exception {
        byte[] arrayOfByte = new byte[16];
        if (key == null)
            throw new IllegalArgumentException("seed == null");
        if (key.length == 0)
            throw new IllegalArgumentException("seed.length == 0");
        if (key.length < 16) {
            int i = 0;
            while (i < arrayOfByte.length) {
                if (i < key.length) {
                    arrayOfByte[i] = key[i];
                } else {
                    arrayOfByte[i] = 0;
                }
                i++;
            }
        }
        return arrayOfByte;
    }

    public static byte[] toByte(String content) {
        int i = content.length() / 2;
        byte[] arrayOfByte = new byte[i];
        for (int j = 0; j < i; j++)
            arrayOfByte[j] = Integer.valueOf(
                    content.substring(j * 2, 2 + j * 2), 16).byteValue();
        return arrayOfByte;
    }

    public static String toHex(String content) {
        return toHex(content.getBytes());
    }

    public static String toHex(byte[] content) {
        if (content == null)
            return "";
        StringBuffer localStringBuffer = new StringBuffer(
                2 * content.length);
        for (int i = 0; i < content.length; i++)
            appendHex(localStringBuffer, content[i]);
        return localStringBuffer.toString();
    }

    private static String readFromFile(File f) {
        if (!f.exists()) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        try {
            byte[] buf = new byte[4096];
            int read = 0;
            FileInputStream fis = new FileInputStream(f);
            while ((read = fis.read(buf)) > 0) {
                builder.append(new String(buf, 0, read));
            }
            fis.close();
            return builder.toString();
        } catch (Exception e) {
        }
        return null;
    }

    private static void writeToFile(File f, String out) {
        try {
            if (f.exists()) {
                f.delete();
            }
            f.createNewFile();
            FileOutputStream fos = new FileOutputStream(f);
            fos.write(out.getBytes());
            fos.close();
        } catch (Exception e) {
        }
    }

    private static void usage() {
        String usage = "java -jar aes.jar <-k rawkey> [-e/-d] [-i input] [-o output] [-s str]";
        System.out.println(usage);
    }

    private static boolean isEmpty(String str) {
        if (str == null || str.trim().equals("")) {
            return true;
        }
        return false;
    }

    public static void encryptFile(String originFile, String secret) {
        try {
            String encrypt = encryptPublic(secret, readFromFile(new File(originFile))); //加密
            writeToFile(new File(originFile), encrypt);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String byte2MD5(byte[] byteArray) {
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
        byte[] md5Bytes = md5.digest(byteArray);
        StringBuffer hexValue = new StringBuffer();
        for (int i = 0; i < md5Bytes.length; i++) {
            int val = md5Bytes[i] & 0xff;
            if (val < 16) {
                hexValue.append("0");
            }
            hexValue.append(Integer.toHexString(val));
        }
        return hexValue.toString();
    }

    public static String string2MD5(String source) {
        return string2MD5(source, "utf-8");
    }

    public static String string2MD5(String source, String encode) {
        try {
            return byte2MD5(source.getBytes(encode));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "";
    }
}